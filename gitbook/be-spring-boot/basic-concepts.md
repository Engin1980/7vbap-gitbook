---
icon: square-3
description: >-
  This chapter explain, how basic implementation patterns are set up for further
  development, namely services and exception management, error handling, logging
  and object mapping.
---

# Basic concepts

In this section, we will explain some basic building concepts used in the rest of the implementation.

## Logging

**Logging** is the practice of recording messages or events generated by an application during its execution. These messages can provide critical insights into the application's behavior, helping developers and system administrators monitor and debug the application.

A log message usually includes several components: a timestamp indicating when the log entry was created, the log level showing the severity of the message, the message content itself describing the event, and any contextual information that provides additional insights, such as thread ID, class name, or user ID.

<table><thead><tr><th width="144">Log Level</th><th>Meaning</th></tr></thead><tbody><tr><td>DEBUG</td><td>Detailed information, typically of interest only when diagnosing problems.</td></tr><tr><td>INFO</td><td>General information about the application's operation (e.g., startup messages, configuration) or about a success.</td></tr><tr><td>WARN</td><td>Indications that something unexpected happened, but the application is able to resolve this issue (e.g. by using some default value) and is still functioning as expected.</td></tr><tr><td>ERROR</td><td>Error events means a part of the aplication crashed or will not work (e.g. missing e-mail module), but the rest of the application is able to continue running.</td></tr><tr><td>FATAL</td><td>Severe error events that might lead the application to abort.</td></tr></tbody></table>

{% hint style="info" %}
Some frameworks use more granular log levels. One of typically used log levels is TRACE/VERBOSE, which is more detailed and low level than debug, used for precise analysis.

The last item, FATAL, is also sometimes marked as CRITICAL.
{% endhint %}

Logs can be output to various destinations. Commonly, they are printed to the console, written to files on disk, sent to centralized logging systems for analysis, or stored in a database for further querying and reporting. Many programming languages offer libraries or frameworks to facilitate logging; for instance, Java has Log4j, SLF4J, Logback, and java.util.logging. We will show an usage of SFL4J.

### Set up Logging using SFL4J + Logback

Logging in Java is divided into an abstraction level and a current implementation. The abstraction is typically represented by SFL4J (Simple Logging Facade 4 Java). For implementation there are several options; however, the default option in Spring Boot is _Logback_.

As our selection is a default option for Spring Boot included in _spring-boot-starter_ dependency, there is no need for additional set up in Maven.

#### Setting up the configuration

To adjust the logging, you should set up the configuration in `application.properties` file:

```properties
...
logging.level.org.springframework.web: DEBUG
logging.level.org.hibernate: INFO
logging.file.name=log/log.txt  # comment this line to disable logging to file
```

#### Creating and usage of the loggers

A logger is an instance of a logging class, which is used to write into the log. To create an instance, a method of a factory class is invoked:

```java
Logger log = LoggerFactory.getLogger(this.getClass());
```

For an instance, a name is typically provided. The name can also be derived from the name of the class. Over this `logger` instance, methods `debug()`, `info()`, `warn()`, `error()` and `critical()` can ve invoked to pass the log record.

```java
log.info("This is a message.");
```

{% hint style="info" %}
The whole problematic is a bit more complicated. To see and understand the exact components of logging in Java, see the link below.
{% endhint %}

{% embed url="https://medium.com/@AlexanderObregon/enhancing-logging-with-log-and-slf4j-in-spring-boot-applications-f7e70c6e4cc7" %}
Introduction to Logging with Spring Boot and Java
{% endembed %}

### Logging + Aspects (AOP)

Aspect-Oriented Programming (AOP) allows the separation of cross-cutting concerns from the main business logic of an application. Cross-cutting concerns are functionalities that affect multiple parts of an application but are not the primary focus of the application, such as logging, security, error handling, transaction management, and performance monitoring.&#x20;

There are five main concepts in AOP:

* **Aspect**: An aspect is a module that encapsulates a cross-cutting concern. It defines a set of behaviors (advice) that can be applied at specific points in the application (join points).
* **Join Point**: A join point is a specific point in the execution of a program where an aspect can be applied. This could be at method entry or exit, exception handling, or even during field access.
* **Advice**: Advice is the action taken by an aspect at a particular join point. There are different types of advice:
  * **Before**: Executed before the join point.
  * **After**: Executed after the join point, regardless of its outcome.
  * **After Returning**: Executed after the join point only if it completes successfully.
  * **After Throwing**: Executed if the join point throws an exception.
  * **Around**: Wraps the join point, allowing you to execute code both before and after the join point, and control whether the join point is executed at all.
* **Pointcut**: A pointcut is an expression that specifies a set of join points where advice should be applied. It allows you to define the conditions under which the advice should be executed.
* **Weaving**: Weaving is the process of integrating aspects with the main codebase. This can occur at different times:
  * **Compile-time**: Aspects are woven into the code during compilation.
  * **Load-time**: Aspects are woven into the code when the classes are loaded into the JVM.
  * **Runtime**: Aspects are woven into the code while the application is running.

In our project, we will show how use AOP for logging the method invocation and result. We will log invocation of every method in any service and in any controller.

#### Adding AOP support to project

To support AOP, a dependency must be added to `pom.xml` Maven file:

```xml
<!-- for AOP -->
<dependency>
    <groupId>org.springframework.boot</groupId>
    <artifactId>spring-boot-starter-aop</artifactId>
</dependency>
```

#### Add Aspect for Controllers

Lets create a new class at `.../src/main/cz.osu.vbap/favUrls/lib/aop` named `ControllerAspect` with the following code:

{% code lineNumbers="true" %}
```java
package cz.osu.vbap.favUrls.lib.aop;

import cz.osu.vbap.favUrls.services.AppService;
import org.aspectj.lang.JoinPoint;
import org.aspectj.lang.annotation.*;
import org.slf4j.Logger;
import org.slf4j.LoggerFactory;
import org.springframework.stereotype.Component;

import java.util.Arrays;

@Aspect
@Component
public class ControllerAspect {
  private final Logger logger = LoggerFactory.getLogger(this.getClass());

  @Pointcut("execution(* cz.osu.vbap.favUrls.controllers..*(..))")
  public void controllerMethods(){}

  @Before("controllerMethods()")
  public void logBefore(JoinPoint joinPoint) {
    String className = joinPoint.getTarget().getClass().getSimpleName();
    String methodName = joinPoint.getSignature().getName();
    String methodArgs = Arrays.toString(joinPoint.getArgs());
    logger.info("AOP-C:: {}.{}() invoked with arguments: {}", className, methodName, methodArgs);
  }

  @AfterReturning(pointcut = "controllerMethods()", returning = "result")
  public void logAfterReturning(JoinPoint joinPoint, Object result) {
    String className = joinPoint.getTarget().getClass().getSimpleName();
    String methodName = joinPoint.getSignature().getName();
    String methodArgs = Arrays.toString(joinPoint.getArgs());
    logger.info("AOP-C:: {}.{}() completed with arguments: {} and result: {}", className, methodName, methodArgs, result);
  }

  @AfterThrowing(pointcut = "controllerMethods()", throwing = "exception")
  public void logAfterThrowing(JoinPoint joinPoint, Throwable exception) {
    String className = joinPoint.getTarget().getClass().getSimpleName();
    String methodName = joinPoint.getSignature().getName();
    String methodArgs = Arrays.toString(joinPoint.getArgs());
    logger.error("AOP-C:: {}.{}() failed with arguments: {}", className, methodName, methodArgs, exception);
  }
}
```
{% endcode %}

Important notes:

* Every aspect must be introduced with `@Aspect` and `@Component` annotations to be active.
* A default logger is created for this aspect - line 15.
* A point cut defines, when the aspect is active - line 17. Our point cut activates the aspect for every class in the defined package.
* Three advices are created. The first advice defines when is it active (line 20) and a joint point parameter argument with the invocation context.

#### Add Aspect for AppServices

In our project, all business logic services will be inherited from a base class `AppService`. We will create a new aspect and configure it to be invoked when any method in of any `AppService` descendant is executed.

Lets create a new class at `.../src/main/cz.osu.vbap/favUrls/lib/aop` named `AppServiceAspect` with the following code:

{% code lineNumbers="true" %}
```java
package cz.osu.vbap.favUrls.lib.aop;

import cz.osu.vbap.favUrls.services.AppService;
import org.aspectj.lang.JoinPoint;
import org.aspectj.lang.annotation.*;
import org.slf4j.Logger;
import org.slf4j.LoggerFactory;
import org.springframework.stereotype.Component;

import java.util.Arrays;

@Aspect
@Component
public class ControllerAspect {
  private final Logger logger = LoggerFactory.getLogger(this.getClass());

  @Pointcut("execution(* cz.osu.vbap.favUrls.controllers..*(..))")
  public void controllerMethods(){}

  @Before("controllerMethods()")
  public void logBefore(JoinPoint joinPoint) {
    String className = joinPoint.getTarget().getClass().getSimpleName();
    String methodName = joinPoint.getSignature().getName();
    String methodArgs = Arrays.toString(joinPoint.getArgs());
    logger.info("AOP-C:: {}.{}() invoked with arguments: {}", className, methodName, methodArgs);
  }

  @AfterReturning(pointcut = "controllerMethods()", returning = "result")
  public void logAfterReturning(JoinPoint joinPoint, Object result) {
    String className = joinPoint.getTarget().getClass().getSimpleName();
    String methodName = joinPoint.getSignature().getName();
    String methodArgs = Arrays.toString(joinPoint.getArgs());
    logger.info("AOP-C:: {}.{}() completed with arguments: {} and result: {}", className, methodName, methodArgs, result);
  }

  @AfterThrowing(pointcut = "controllerMethods()", throwing = "exception")
  public void logAfterThrowing(JoinPoint joinPoint, Throwable exception) {
    String className = joinPoint.getTarget().getClass().getSimpleName();
    String methodName = joinPoint.getSignature().getName();
    String methodArgs = Arrays.toString(joinPoint.getArgs());
    logger.error("AOP-C:: {}.{}() failed with arguments: {}", className, methodName, methodArgs, exception);
  }
}

```
{% endcode %}

Code is very similar. There are two significant defferences:

* The point cut a line 17 is different, now aimed at the all descendants of the (not yet existing) `AppService` class.
* &#x20;The only difference is that the logger is taken from the invocating source - a descendant of `AppService` class. `AppService` defines the logger of the service, and we use this logger for logging.

{% hint style="info" %}
Note that as the class `AppService`does not exist yet; the project with `AppServiceAspect` class is not now compilable.

To overcome this issue, you can comment this whole file and uncomment it once the `AppService` class is created.
{% endhint %}

## Service

## Repository

### Dependency Injection

### RestController

### DTO - Data Transfer Object

## Services management

todo

### Service exceptions

TODO

### Base service

todo

### URL Service - prototype

## REST API

### Exception handling

todo

### URL REST API - prototype

todo

## Sidenotes

TODO

